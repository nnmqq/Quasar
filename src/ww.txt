// main.c
#include "util/error.h"
#include "util/logger.h"
#include <stdio.h>
#include <window/window.h>

void test(){

  QS_REPORT_ERROR(QS_NO_ERROR);
  QS_LOG(QS_LOG_LEVEL_INFO, "message");
  QS_LOG(QS_LOG_LEVEL_ERROR, "message");
  QS_LOG(QS_LOG_LEVEL_WARNING, "message");
  QS_LOG(QS_LOG_LEVEL_FATAL, "message");
}
int main() {
    // Initialize the API interface for OpenGL
    QuasarAPIInterface apiInterface;
    initializeAPIInterface(&apiInterface, QUASAR_API_OPENGL);

    // Configuration for the windows
    QsConfig config1 = {800, 600, "OpenGL Window 1", 1, 1, 4, 4, 0, QUASAR_API_OPENGL};
    QsConfig config2 = {1024, 768, "OpenGL Window 2", 1, 1, 4, 4, 0, QUASAR_API_OPENGL};

    // Create two OpenGL windows
    QsWindow window1;
    QsWindow window2;

    if (apiInterface.createWindow(&window1, &config1) != 0) {
        fprintf(stderr, "Failed to create window 1.\n");
        return -1;
    }

    if (apiInterface.createWindow(&window2, &config2) != 0) {
        fprintf(stderr, "Failed to create window 2.\n");
        apiInterface.destroyWindow(&window1);
        return -1;
    }

    // Set contexts for the windows
    apiInterface.setContext(&window1);
    apiInterface.setContext(&window2);

    // Set Vsync
    apiInterface.setVsync(&window1, 1);
    apiInterface.setVsync(&window2, 1);

    // Main loop for rendering (simplified)
    while (!glfwWindowShouldClose(window1.window) && !glfwWindowShouldClose(window2.window)) {
        // Render and swap buffers
        apiInterface.setContext(&window1);
        // Render code for window1...
        apiInterface.setContext(&window2);
        // Render code for window2...

        apiInterface.setContext(&window1);
        glfwSwapBuffers(window1.window);
        apiInterface.setContext(&window2);
        glfwSwapBuffers(window2.window);

        apiInterface.setContext(&window1);
        glfwPollEvents();
        apiInterface.setContext(&window2);
        glfwPollEvents();
    }

    // Destroy the windows
    apiInterface.destroyWindow(&window1);
    apiInterface.destroyWindow(&window2);

    // Terminate the OpenGL API
    apiInterface.terminateAPI();

    return 0;
}

// opengl.c
#include <stdlib.h>
#include <util/error.h>
#include <util/logger.h>
#include <window/opengl.h>

int qsOpenglCreateWindow(QsWindow* win, QsConfig* config)
{
  // Initialize GLFW if it hasn't been initialized already
  if (!windowVar.isGlfwInitialized) {
    if (!glfwInit()) {
      QS_REPORT_ERROR(QS_ERROR_INITIALIZATION);
      return -1;
    }
    windowVar.isGladInitialized = 1;
  }

  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, config->glMajorVersion);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, config->glMinorVersion);
  glfwWindowHint(GLFW_OPENGL_PROFILE, config->openglProfile);

  if (config->resizable) {
    glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);
  } else {
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
  }

  if (config->samples > 0) {
    glfwWindowHint(GLFW_SAMPLES, config->samples);
  }

  // Create the GLFW window
  win->window = glfwCreateWindow(config->width, config->height, config->title, NULL, NULL);
  if (!win->window) {
    QS_REPORT_ERROR(QS_ERROR_WINDOW_CREATION);
    glfwTerminate();
    return -1;
  }

  // Set the window's initial state
  win->width = config->width;
  win->height = config->height;
  win->title = config->title;
  win->resizable = config->resizable;
  win->vsync = config->vsync;
  win->id = (int)(intptr_t)win->window;

  // Make the OpenGL context current for the window
  glfwMakeContextCurrent(win->window);

  // Enable VSync if specified
  qsOpenglSetVsync(win, config->vsync);

  // Initialize GLAD for OpenGL function loading
  if (!windowVar.isGladInitialized) {
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
      glfwDestroyWindow(win->window);
      glfwTerminate();
      QS_REPORT_ERROR(QS_ERROR_INITIALIZATION);
      return -1;
    }
    windowVar.isGladInitialized = 1;
  }

  if (windowManager.windowCount >= windowVar.capacity) {
    windowVar.capacity *= 2;
    QsWindow* temp = realloc(windowManager.windows, sizeof(QsWindow) * windowVar.capacity);
    if (!temp) {
      glfwDestroyWindow(win->window);
      glfwTerminate();
      QS_REPORT_ERROR(QS_ERROR_MEMORY_ALLOCATION_FAILURE);
      return -1;
    }
    windowManager.windows = temp;
  }

  windowManager.windows[windowManager.windowCount] = *win;
  windowManager.windowCount++;

  return 0;
}

void qsOpenglSetContext(QsWindow* win)
{
  if (win && win->window) {
    glfwMakeContextCurrent(win->window);
  } else {
    QS_REPORT_ERROR(QS_ERROR_INVALID_WINDOW);
  }
}

void qsOpenglSetVsync(QsWindow* win, int vsync)
{
  if (win && win->window) {
    if (vsync == 0) {
      glfwSwapInterval(0); // Disable V-Sync
    } else if (vsync == 1) {
      glfwSwapInterval(1); // Enable V-Sync
    } else {
      // Handle invalid vsync value, e.g., log an error message or assert
      QS_REPORT_ERROR(QS_ERROR_INVALID_VSYNC_VALUE);
    }
  } else {
    // Handle the error, e.g., log an error message or assert
    QS_REPORT_ERROR(QS_ERROR_INVALID_WINDOW);
  }
}

void qsOpenglDestroyWindow(QsWindow* win)
{
  if (!win || !win->window) {
    QS_REPORT_ERROR(QS_ERROR_INVALID_WINDOW);
    return;
  }

  // Destroy the GLFW window
  glfwDestroyWindow(win->window);
  win->window = NULL;

  // Remove the window from the windowManager array
  int index = -1;
  for (int i = 0; i < windowManager.windowCount; i++) {
    if (windowManager.windows[i].id == win->id) {
      index = i;
      break;
    }
  }

  if (index != -1) {
    // Shift remaining windows to fill the gap
    for (int i = index; i < windowManager.windowCount - 1; i++) {
      windowManager.windows[i] = windowManager.windows[i + 1];
    }

    // Resize the window array
    QsWindow* temp = realloc(windowManager.windows, sizeof(QsWindow) * (windowManager.windowCount - 1));
    if (temp || windowManager.windowCount == 1) { // Allow realloc to shrink to 0 windows
      windowManager.windows = temp;
      windowManager.windowCount--;
    } else {
      QS_REPORT_ERROR(QS_ERROR_MEMORY_ALLOCATION_FAILURE);
    }
  }
}

void qsOpenglTerminateAPI()
{
  for (int i = 0; i < windowManager.windowCount; i++) {
    if (windowManager.windows[i].window) {
      qsOpenglDestroyWindow(&windowManager.windows[i]);
    }
  }

  // Free the window array if it's not NULL
  if (windowManager.windows) {
    free(windowManager.windows);
    windowManager.windows = NULL;
  }
  windowManager.windowCount = 0;

  // Terminate GLFW
  if (windowVar.isGlfwInitialized) {
    glfwTerminate();
    windowVar.isGlfwInitialized = 0;
  }
}

// window.c
#include <window/opengl.h>
#include <window/window.h>

QsWinVar windowVar = {.isGlfwInitialized=0, .isGladInitialized=0};
QsWindowManager windowManager = { NULL, 0, INITIAL_WINDOW_CAPACITY };

void initializeAPIInterface(QuasarAPIInterface* apiInterface, QsAPI api)
{
  switch (api) {
  case QUASAR_API_OPENGL:
    apiInterface->createWindow = qsOpenglCreateWindow;
    apiInterface->setContext = qsOpenglSetContext;
    apiInterface->setVsync = qsOpenglSetVsync;
    apiInterface->destroyWindow = qsOpenglDestroyWindow;
    apiInterface->terminateAPI = qsOpenglTerminateAPI;
    break;

  case QUASAR_API_VULKAN:
    break;

  case QUASAR_API_DIRECTX:
    break;

  default:
    break;
  }
}

//opengl.h
#ifndef OPENGL_H
#define OPENGL_H

#include <window/window.h>

#define GLAD_GL_IMPLEMENTATION
#include <glad/glad.h>

// OpenGL-specific function declarations
// OpenGL-specific function declarations
int qsOpenglCreateWindow(QsWindow* win, QsConfig* config);
void qsOpenglSetContext(QsWindow* win);
void qsOpenglSetVsync(QsWindow* win, int vsync);
void qsOpenglDestroyWindow(QsWindow* win);
void qsOpenglTerminateAPI();

int qsOpenglGetWindowCount();
QsWindow* qsOpenglGetWindowByIndex(int index);
QsWindow* qsOpenglGetWindowByID(int windowID);
int qsOpenglIsWindowOpen(QsWindow* win);
void qsOpenglSetWindowPosition(QsWindow* win, int x, int y);
void qsOpenglSetWindowSize(QsWindow* win, int width, int height);
void qsOpenglGetWindowSize(QsWindow* win, int* width, int* height);
void qsOpenglGetWindowPosition(QsWindow* win, int* x, int* y);
void qsOpenglSetWindowIcon(QsWindow* win, const char* iconPath);
void qsOpenglSetWindowOpacity(QsWindow* win, float opacity);
void qsOpenglSetWindowFullscreen(QsWindow* win, int fullscreen);
void qsOpenglSetWindowBorderless(QsWindow* win, int borderless);
void qsOpenglToggleFullscreen(QsWindow* win);
void qsOpenglSetWindowFocus(QsWindow* win);
void qsOpenglShowWindow(QsWindow* win);
void qsOpenglHideWindow(QsWindow* win);
void qsOpenglMinimizeWindow(QsWindow* win);
void qsOpenglMaximizeWindow(QsWindow* win);
void qsOpenglRestoreWindow(QsWindow* win);

void qsOpenglPollEvents();
void qsOpenglSetEventCallback(QsWindow* win, void (*callback)(QsWindow* win, int eventType, ...));
int qsOpenglShouldClose(QsWindow* win);

int qsOpenglIsKeyPressed(QsWindow* win, int keyCode);
int qsOpenglIsKeyReleased(QsWindow* win, int keyCode);
int qsOpenglIsKeyDown(QsWindow* win, int keyCode);
int qsOpenglIsKeyUp(QsWindow* win, int keyCode);
int qsOpenglIsMouseButtonPressed(QsWindow* win, int button);
int qsOpenglIsMouseButtonReleased(QsWindow* win, int button);
int qsOpenglIsMouseButtonDown(QsWindow* win, int button);
int qsOpenglIsMouseButtonUp(QsWindow* win, int button);
void qsOpenglGetMousePosition(QsWindow* win, double* xpos, double* ypos);

void qsOpenglSwapBuffers(QsWindow* win);
void qsOpenglMakeContextCurrent(QsWindow* win);
void qsOpenglGetCurrentContext(QsWindow** win);
void qsOpenglShareContext(QsWindow* win1, QsWindow* win2);
void qsOpenglCreateContext(QsWindow* win);
void qsOpenglDestroyContext(QsWindow* win);
int qsOpenglGetCurrentContextID();
void qsOpenglMakeContextCurrentByID(int contextID);

void qsOpenglSetWindowUserData(QsWindow* win, void* data);
void* qsOpenglGetWindowUserData(QsWindow* win);

int qsOpenglGetAPI();
void qsOpenglSetAPI(QsAPI api);

#endif // OPENGL_H

// window.h 
#ifndef WINDOW_H
#define WINDOW_H

#define INITIAL_WINDOW_CAPACITY 4

// Graphics api backend
#define GLFW_INCLUDE_NONE
#include <GLFW/glfw3.h>

typedef enum {
  QUASAR_API_OPENGL,
  QUASAR_API_VULKAN,
  QUASAR_API_DIRECTX
} QsAPI;

typedef struct {
  int isGlfwInitialized;
  int isGladInitialized;
  int capacity;
} __attribute__((aligned(16))) QsWinVar;

// Basic window settings
typedef struct {
  int width;
  int height;
  const char* title;
  int resizable;
  int vsync;
  int samples;
  int glMajorVersion;
  int glMinorVersion;
  int openglProfile;
  QsAPI api;
} __attribute__((aligned(64))) QsConfig;

typedef struct {
  int width;
  int height;
  const char* title;
  GLFWwindow* window;
  int resizable;
  int vsync;
  int id;
} __attribute__((aligned(64))) QsWindow;

typedef struct {
    QsWindow* windows;
    int windowCount;
} __attribute__((aligned(16))) QsWindowManager;

typedef struct {
    // Window Management
    int (*createWindow)(QsWindow* win, QsConfig* config);
    void (*setContext)(QsWindow* win);
    void (*setVsync)(QsWindow* win, int vsync);
    void (*destroyWindow)(QsWindow* win);
    void (*terminateAPI)();

    // Core Window Manipulation
    int (*getWindowCount)();
    QsWindow* (*getWindowByIndex)(int index);
    QsWindow* (*getWindowByID)(int windowID);
    int (*isWindowOpen)(QsWindow* win);
    void (*setWindowPosition)(QsWindow* win, int x, int y);
    void (*setWindowSize)(QsWindow* win, int width, int height);
    void (*getWindowSize)(QsWindow* win, int* width, int* height);
    void (*getWindowPosition)(QsWindow* win, int* x, int* y);
    void (*setWindowIcon)(QsWindow* win, const char* iconPath);
    void (*setWindowOpacity)(QsWindow* win, float opacity);
    void (*setWindowFullscreen)(QsWindow* win, int fullscreen);
    void (*setWindowBorderless)(QsWindow* win, int borderless);
    void (*toggleFullscreen)(QsWindow* win);
    void (*setWindowFocus)(QsWindow* win);
    void (*showWindow)(QsWindow* win);
    void (*hideWindow)(QsWindow* win);
    void (*minimizeWindow)(QsWindow* win);
    void (*maximizeWindow)(QsWindow* win);
    void (*restoreWindow)(QsWindow* win);

    // Event Handling
    void (*pollEvents)();
    void (*setEventCallback)(QsWindow* win, void (*callback)(QsWindow* win, int eventType, ...));
    int (*shouldClose)(QsWindow* win);

    // Input Handling
    int (*isKeyPressed)(QsWindow* win, int keyCode);
    int (*isKeyReleased)(QsWindow* win, int keyCode);
    int (*isKeyDown)(QsWindow* win, int keyCode);
    int (*isKeyUp)(QsWindow* win, int keyCode);
    int (*isMouseButtonPressed)(QsWindow* win, int button);
    int (*isMouseButtonReleased)(QsWindow* win, int button);
    int (*isMouseButtonDown)(QsWindow* win, int button);
    int (*isMouseButtonUp)(QsWindow* win, int button);
    void (*getMousePosition)(QsWindow* win, double* xpos, double* ypos);

    // Context and Rendering
    void (*swapBuffers)(QsWindow* win);
    void (*makeContextCurrent)(QsWindow* win);
    void (*getCurrentContext)(QsWindow** win);
    void (*shareContext)(QsWindow* win1, QsWindow* win2);
    void (*createContext)(QsWindow* win); // Create a new context for a window
    void (*destroyContext)(QsWindow* win); // Destroy the context associated with a window
    int (*getCurrentContextID)(); // Get the ID of the currently active context
    void (*makeContextCurrentByID)(int contextID); // Make a context current by its ID

    // Custom Data
    void (*setWindowUserData)(QsWindow* win, void* data);
    void* (*getWindowUserData)(QsWindow* win);

    // Backend Agnostic
    int (*getAPI)();
    void (*setAPI)(QsAPI api);
} __attribute__((aligned(128))) QuasarAPIInterface;

void initializeAPIInterface(QuasarAPIInterface* apiInterface, QsAPI api);

extern QsWinVar windowVar;
extern QsWindowManager windowManager;

#endif // WINDOW_H
